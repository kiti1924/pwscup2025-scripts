# `mia.py`：距離ベースのメンバーシップ推論攻撃（MIA）
- 概要：2つの同一ヘッダー付きCSV（Ai.csv と Ci.csv）を読み込み、Ci の各行に最も近い Ai の行を最近傍探索で求め、その Ai 側の行を 1、それ以外を 0 として並べた 1 列・ヘッダー無しのCSVファイル Fij.csv を出力。Fijの行数はヘッダー無しの Ai の行数-1になる。近さ（距離）は、数値列＋カテゴリ列が混在していても扱えるように前処理した特徴量空間での マンハッタン距離（L1）で定義。
- 入力：
    - `Ai.csv`：大元のデータ（例：10万行）
    - `Ci.csv`：Ai.csvをサンプリング（例：1万行）したBi.csvを匿名化したデータ
- 出力：`-o Fij.csv` で指定（既定 `Fij.csv`）。1列、ヘッダー無し、各値は0/1
- 使い方の例：`python3 mia.py Ai.csv Ci.csv`
- 前処理と特徴量化の流れ：混在型データ（数値＋カテゴリ）を同じ空間で距離計算できるよう、以下の手順で両データを同一の特徴量空間に整形。
    1. 列タイプの推定（Ai を基準）：各共通列について、95%以上が数値化可能なら数値列と判定し、それ以外はカテゴリ列と見なす
    2. 数値列の整形：Ai 側から列ごとに min-max（最小–最大）を取得し、Ai/Ci の両方を [0,1] にスケーリング。ゼロ分散（min=max）の列は距離に寄与しないため除外
    3. カテゴリ列の整形：Ai と Ci を縦に結合してから OneHot 化、その後に元の Ai/Ci に分割。これにより、同じダミー列集合・同じ列順で両データを比較でき、Ci にだけ登場するカテゴリも対応可能になる
    4. 特徴行列の結合：スケーリング済みの数値特徴と、OneHot 化したカテゴリ特徴を横結合し、`float32` の NumPy 行列（X1 と X2）にして距離計算の準備。全列が除外されて次元が 0 になった場合は、比較不能として 全て 0 を出力 
- 最近傍探索（Nearest Neighbors）：`sklearn.neighbors.NearestNeighbors(metric="manhattan", n_neighbors=1)` を用いて、Ci 各行の最近傍となる Ai の行インデックス（0始まり）を求める。その後、見つかったインデックス集合を Ai 長の 0/1 ベクトルに反映し、該当位置を 1 にする。

# `attack_Di.py`：学習モデルに対する攻撃者クラスの実装例
- いずれのクラスもモデルJSONへのパスを渡してインスタンス生成、`infer`にAi.csvへパスを渡して攻撃、`save_inferred`に保存名を渡して攻撃結果を保存という共通のメソッドを持つ
- 実装した各攻撃者クラスの使用例を`if __name__ == "__main__":`のブロックに配置した。
- このような攻撃者単体でメンバーシップを推定するよりも、上のmia.pyのようなCiからメンバーシップを推定する攻撃と組み合わせて推定することを想定。
## 抽象クラス`Attack_Di_Base`
- 多くの攻撃者で使いまわせると考えられる処理を定義
- 攻撃メソッド`infer`と攻撃結果保存メソッド`save_inferred`には本コンペ固有の実装が必要になる部分を含めて、参加が試行錯誤する必要のない部分を明確化
- XGBoostモデルへのデータの入力の仕方や攻撃結果の様式に本コンペ固有の規則があるので、注意されたし
- このクラスを継承して攻撃を実装する必要はない。一から実装を自作するのも自由。

## 攻撃者クラス `Pred_Attack`
モデルが正答した行をmemberと推定する。間違えた行は非メンバーと推定。

## 攻撃者クラス `Conf_Attack`
モデルが確信を持って正答した行をメンバーと推定する。インスタンス作成時により小さいthresholdを指定することで、要求する確信度を高められる。

# `attack_Ci.py`: `mia.py`と同等
 `mia.py`を`attack_Di.py`と同様の書き方に変更したもの。

# `attack_example.py`: `Fij`生成例
- CiとDi両方を使って、Aiの各行がBiに属するかどうかを推定する攻撃のサンプル。
- `attack_Ci.py`と`attack_Di.py`に実装されている攻撃手法でそれぞれ攻撃し、多数決で推定
